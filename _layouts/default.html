<!DOCTYPE html>
<html lang="en">
{% include head.html %}
<body>

{% include header.html %}

{{ content }}

{% include footer.html %}

{% if page.url == "/" %}
<script>
// D3.js Agent Network Visualization
function initializeAgentNetwork() {
  const container = d3.select("#agent-network-d3");
  if (container.empty()) return;

  const width = window.innerWidth;
  const height = window.innerHeight;

  // Clear previous SVG
  container.selectAll("*").remove();

  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("position", "absolute")
    .style("top", "0")
    .style("left", "0")
    .style("pointer-events", "none")
    .style("z-index", "1");

  // Create clipping mask to hide lines/signals inside circles
  const defs = svg.append("defs");
  const clipPath = defs.append("clipPath")
    .attr("id", "agent-mask");
  
  // Add background rectangle
  clipPath.append("rect")
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "white");

  // Agent data with roles and initial positions - responsive sizes
  const baseSize = Math.min(width / 15, height / 20, 40);
  const agents = [
    { id: 'pm', role: 'PM', size: baseSize * 0.9, color: '#64748B' },
    { id: 'backend', role: 'BE', size: baseSize, color: '#64748B' },
    { id: 'frontend', role: 'FE', size: baseSize * 0.95, color: '#64748B' },
    { id: 'qa', role: 'QA', size: baseSize * 0.8, color: '#64748B' },
    { id: 'devops', role: 'Ops', size: baseSize * 0.85, color: '#64748B' },
    { id: 'security', role: 'Sec', size: baseSize * 0.75, color: '#64748B' }
  ];

  // Position agents equally spread around center (hero text area)
  const centerX = width * 0.5;
  const centerY = height * 0.5;
  // Responsive radius based on viewport size
  const radius = Math.min(width * 0.35, height * 0.3, 450);
  
  agents.forEach((agent, index) => {
    // Equal spacing around circle
    const angle = (index / agents.length) * Math.PI * 2;
    agent.x = centerX + Math.cos(angle) * radius;
    agent.y = centerY + Math.sin(angle) * radius;
    // Very slow orbital movement
    agent.angle = angle;
    agent.angularVelocity = 0.0002; // Even slower rotation
  });

  // Connection data - ensure each agent connects to at least 2 others
  const connections = [
    // PM connections (3 total)
    { source: 'pm', target: 'backend' },
    { source: 'pm', target: 'frontend' },
    { source: 'pm', target: 'qa' },
    // Backend connections (3 total)
    { source: 'backend', target: 'devops' },
    { source: 'backend', target: 'security' },
    // Frontend connections (3 total)
    { source: 'frontend', target: 'qa' },
    { source: 'frontend', target: 'devops' },
    // QA connections (2 total)
    { source: 'qa', target: 'security' },
    // DevOps connections (2 total)
    { source: 'devops', target: 'security' },
    // Security has connections from others (3 total)
  ];

  // Add agent circles to clipping mask (black holes in white background)
  const maskCircles = clipPath.selectAll(".mask-circle")
    .data(agents)
    .enter()
    .append("circle")
    .attr("class", "mask-circle")
    .attr("cx", d => d.x)
    .attr("cy", d => d.y)
    .attr("r", d => d.size)
    .attr("fill", "black");

  // Create a container for clipped elements (lines and signals)
  const clippedGroup = svg.append("g")
    .attr("clip-path", "url(#agent-mask)");

  // Create connections inside clipped group
  const lines = clippedGroup.selectAll(".connection")
    .data(connections)
    .enter()
    .append("line")
    .attr("class", "connection")
    .attr("stroke", "#64748B")
    .attr("stroke-width", 1)
    .attr("opacity", 0.4);

  // Create agent circles (these will be on top, unclipped)
  const agentGroups = svg.selectAll(".agent")
    .data(agents)
    .enter()
    .append("g")
    .attr("class", "agent");

  // Agent circles - solid background to hide grid and signals
  agentGroups.append("circle")
    .attr("r", d => d.size)
    .attr("fill", "#1e293b")
    .attr("fill-opacity", 1)
    .attr("stroke", "#64748B")
    .attr("stroke-width", 1)
    .attr("stroke-opacity", 0.4);

  // Agent labels - responsive font size
  const fontSize = Math.min(baseSize / 3.5, 12);
  agentGroups.append("text")
    .attr("text-anchor", "middle")
    .attr("dy", "0.35em")
    .attr("fill", "#94A3B8")
    .attr("font-family", "Inter, sans-serif")
    .attr("font-size", `${fontSize}px`)
    .attr("font-weight", "500")
    .attr("opacity", 0.6)
    .text(d => d.role);

  // Animation function - smooth orbital movement
  function animate() {
    agents.forEach(agent => {
      // Update angle for smooth orbital movement
      agent.angle += agent.angularVelocity;
      
      // Calculate new position based on angle
      agent.x = centerX + Math.cos(agent.angle) * radius;
      agent.y = centerY + Math.sin(agent.angle) * radius;
    });

    // Update agent positions
    agentGroups.attr("transform", d => `translate(${d.x}, ${d.y})`);

    // Update mask circle positions
    maskCircles
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);

    // Update connection lines
    lines
      .attr("x1", d => agents.find(a => a.id === d.source).x)
      .attr("y1", d => agents.find(a => a.id === d.source).y)
      .attr("x2", d => agents.find(a => a.id === d.target).x)
      .attr("y2", d => agents.find(a => a.id === d.target).y);

    requestAnimationFrame(animate);
  }

  // Start animation
  animate();

  // Animated data flow with moving agents - bidirectional and slower
  function animateDataFlow() {
    connections.forEach((conn, index) => {
      // Forward direction
      setTimeout(() => {
        const sourceAgent = agents.find(a => a.id === conn.source);
        const targetAgent = agents.find(a => a.id === conn.target);
        
        const pulse = clippedGroup.append("circle")
          .attr("cx", sourceAgent.x)
          .attr("cy", sourceAgent.y)
          .attr("r", 2)
          .attr("fill", "#94A3B8")
          .attr("opacity", 1.0);

        function updatePulse() {
          const currentTime = Date.now();
          const startTime = currentTime;
          const duration = 4500; // Even slower - increased to 4500ms
          
          function movePulse() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Get current positions of source and target
            const currentSourceX = sourceAgent.x;
            const currentSourceY = sourceAgent.y;
            const currentTargetX = targetAgent.x;
            const currentTargetY = targetAgent.y;
            
            // Interpolate position
            const x = currentSourceX + (currentTargetX - currentSourceX) * progress;
            const y = currentSourceY + (currentTargetY - currentSourceY) * progress;
            
            pulse.attr("cx", x).attr("cy", y).attr("opacity", 1.0 * (1 - progress));
            
            if (progress < 1) {
              requestAnimationFrame(movePulse);
            } else {
              pulse.remove();
            }
          }
          
          movePulse();
        }
        
        updatePulse();
      }, index * 800); // Even slower stagger

      // Reverse direction
      setTimeout(() => {
        const sourceAgent = agents.find(a => a.id === conn.target); // Reversed
        const targetAgent = agents.find(a => a.id === conn.source); // Reversed
        
        const pulse = clippedGroup.append("circle")
          .attr("cx", sourceAgent.x)
          .attr("cy", sourceAgent.y)
          .attr("r", 2)
          .attr("fill", "#94A3B8")
          .attr("opacity", 1.0);

        function updatePulse() {
          const currentTime = Date.now();
          const startTime = currentTime;
          const duration = 4500; // Same slower duration
          
          function movePulse() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Get current positions of source and target
            const currentSourceX = sourceAgent.x;
            const currentSourceY = sourceAgent.y;
            const currentTargetX = targetAgent.x;
            const currentTargetY = targetAgent.y;
            
            // Interpolate position
            const x = currentSourceX + (currentTargetX - currentSourceX) * progress;
            const y = currentSourceY + (currentTargetY - currentSourceY) * progress;
            
            pulse.attr("cx", x).attr("cy", y).attr("opacity", 1.0 * (1 - progress));
            
            if (progress < 1) {
              requestAnimationFrame(movePulse);
            } else {
              pulse.remove();
            }
          }
          
          movePulse();
        }
        
        updatePulse();
      }, index * 800 + 2000); // Offset for reverse direction
    });
  }

  // Start data flow animation loop - even slower interval
  animateDataFlow();
  setInterval(animateDataFlow, 8000);
}


// Basic smooth scroll for anchor links
function initializeNavigation() {
  // Enable smooth scrolling via CSS
  document.documentElement.style.scrollBehavior = 'smooth';
}

// Initialize agent network on load and resize
window.addEventListener('load', () => {
  initializeAgentNetwork();
  initializeNavigation();
});

window.addEventListener('resize', () => {
  initializeAgentNetwork();
});
</script>
{% endif %}

{% if page.url == "/workshop.html" or page.url == "/workshop/" %}
<script>
// Smooth scroll for anchor links
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
  anchor.addEventListener('click', function (e) {
    e.preventDefault();
    const target = document.querySelector(this.getAttribute('href'));
    if (target) {
      target.scrollIntoView({
        behavior: 'smooth',
        block: 'start'
      });
    }
  });
});
</script>
{% endif %}

</body>
</html>